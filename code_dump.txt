========================================
.\src\auth\authUtils.js
========================================
import pkg from 'jsonwebtoken';
const { sign, verify } = pkg;
import { createHash } from 'crypto';

class AuthUtils {
	static TOKEN_TYPES = {
		ACCESS: 'access',
		REFRESH: 'refresh'
	};

	static async createTokenPair(payload, privateKey, publicKey) {
		try {
			// Remove sensitive data from payload
			const tokenPayload = {
				userId: payload.userId,
				email: payload.email,
				roles: payload.roles
			};

			const accessToken = sign(
				{
					...tokenPayload,
					type: this.TOKEN_TYPES.ACCESS
				},
				privateKey,
				{
					algorithm: 'RS256',
					expiresIn: '2d',
					notBefore: '0s', // Token is valid immediately
					jwtid: createHash('sha256').update(Math.random().toString()).digest('hex')
				}
			);

			const refreshToken = sign(
				{
					userId: payload.userId,
					type: this.TOKEN_TYPES.REFRESH
				},
				privateKey,
				{
					algorithm: 'RS256',
					expiresIn: '7d',
					notBefore: '0s',
					jwtid: createHash('sha256').update(Math.random().toString()).digest('hex')
				}
			);

			return { accessToken, refreshToken };
		} catch (error) {
			throw new Error(`Token generation failed: ${error.message}`);
		}
	}

	static async verifyToken(token, publicKey) {
		try {
			return verify(token, publicKey, {
				algorithms: ['RS256']
			});
		} catch (error) {
			throw new Error(`Token verification failed: ${error.message}`);
		}
	}
}

export default AuthUtils;
========================================
.\src\models\keytoken.model.js
========================================
import mongoose from 'mongoose'; 

const DOCUMENT_NAME = 'Key';
const COLLECTION_NAME = 'keys';

const keyTokenSchema = new mongoose.Schema({
	user: {
		type: mongoose.Schema.Types.ObjectId,
		required: true,
		ref: 'Shop'
	},
	publicKey: {
		type: String,
		required: true,
	},
	refreshTokensUsed: {
		type: Array,
		default: []
	},
	refreshToken: {
		type: String,
		required: true
	},
	expiresAt: {
		type: Date,
		required: true
	},
	isRevoked: {
		type: Boolean,
		default: false
	}
}, {
	collection: COLLECTION_NAME,
	timestamps: true
});

// Add indices for faster queries
keyTokenSchema.index({ user: 1 });
keyTokenSchema.index({ refreshToken: 1 });
keyTokenSchema.index({ expiresAt: 1 });

export default mongoose.model(DOCUMENT_NAME, keyTokenSchema);

========================================
.\src\models\shop.model.js
========================================
import mongoose from 'mongoose';
const DOCUMENT_NAME = 'Shop';
const COLLECTION_NAME = 'shops';

var shopSchema = new mongoose.Schema({
    name:{
        type:String,
        trim:true,
        maxLength:150
    },
    email:{
        type:String,
        unique:true,
        trim:true
    },
    password:{
        type:String,
        required:true,
    },
    status:{
        type:String,
        enum:['active','inactive'],
        default:'inactive'
    },
    verify:{
        type:mongoose.Schema.Types.Boolean,
        default:false
    },
    role:{
        type:Array,
        default:[]
    }
}, {
    timestamps: true,
    collection: COLLECTION_NAME
});

export default mongoose.model(DOCUMENT_NAME, shopSchema);
========================================
.\src\services\access.service.js
========================================
import ShopModel from "../models/shop.model.js"
import { hash } from 'bcrypt'
import { generateKeyPairSync, createPublicKey } from 'crypto'
import KeyTokenService from "./keytoken.service.js"
import AuthUtils from "../auth/authUtils.js"
import { getInfoData } from "../utils/index.js"

const RoleShop = {
	SHOP: 'SHOP',
	WRITER: 'WRITER',
	EDITER: 'EDITER',
	ADMIN: 'ADMIN'
}

class AccessService {
	static async signUp({ name, email, password }) {
		try {
			// Input validation
			if (!email || !password || !name) {
				throw new Error('Missing required fields');
			}

			// Check email existence
			const existingShop = await ShopModel.findOne({ email }).lean();
			if (existingShop) {
				throw new Error('Email already exists');
			}

			// Hash password with appropriate cost factor
			const passwordHash = await hash(password, 10);

			// Create shop with minimal required data
			const newShop = await ShopModel.create({
				name,
				email,
				password: passwordHash,
				roles: [RoleShop.SHOP],
			});

			// Generate key pair with appropriate key size
			const { privateKey, publicKey } = generateKeyPairSync('rsa', {
				modulusLength: 4096,
				publicKeyEncoding: {
					type: 'pkcs1',
					format: 'pem'
				},
				privateKeyEncoding: {
					type: 'pkcs1',
					format: 'pem'
				}
			});

			// Create tokens
			const { accessToken, refreshToken } = 
				await AuthUtils.createTokenPair(
					{ userId: newShop._id, email },
					privateKey,
					publicKey
				);

			// Store token info
			await KeyTokenService.createKeyToken({
				userId: newShop._id,
				publicKey,
				refreshToken
			});

			return {
				code: 201,
				metadata: {
					shop: getInfoData({
						fields: ['_id', 'name', 'email'],
						object: newShop
					}),
					tokens: { accessToken, refreshToken }
				}
			};
		} catch (error) {
			throw new Error(`Signup failed: ${error.message}`);
		}
	}

	static async refreshToken(refreshToken) {
        try {
            const keyToken = await KeyTokenService.validateRefreshToken(refreshToken);
            const publicKey = keyToken.publicKey;

            // Verify the refresh token
            await AuthUtils.verifyToken(refreshToken, publicKey);

            // Generate new tokens
            const { userId, email } = await AuthUtils.verifyToken(refreshToken, publicKey);
            const { privateKey, publicKey: newPublicKey } = generateKeyPairSync('rsa', {
                modulusLength: 4096,
                publicKeyEncoding: {
                    type: 'pkcs1',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs1',
                    format: 'pem'
                }
            });

            const { accessToken, refreshToken: newRefreshToken } = await AuthUtils.createTokenPair(
				{ userId, email },
				privateKey,
				newPublicKey
			);

            // Update the refresh token in the database
            await KeyTokenService.updateKeyToken(keyToken._id, newPublicKey, newRefreshToken);

			return {
				code: 200,
				metadata: {
					tokens: { 
						accessToken,
						refreshToken: newRefreshToken // Include new refresh token
					}
				}
			};
        } catch (error) {
            throw new Error(`Refresh token failed: ${error.message}`);
        }
    }
}

export default AccessService

========================================
.\src\services\keytoken.service.js
========================================
import KeyTokenModel from "../models/keytoken.model.js"

class KeyTokenService {
	static async createKeyToken({ userId, publicKey, refreshToken }) {
		try {
			const expiresAt = new Date();
			expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now

			const token = await KeyTokenModel.create({
				user: userId,
				publicKey: publicKey.toString(),
				refreshToken,
				expiresAt
			});

			if (!token) throw new Error('Failed to create key token');
			return token.publicKey;
		} catch (error) {
			throw new Error(`KeyToken creation failed: ${error.message}`);
		}
	}

	static async validateRefreshToken(refreshToken) {
        try {
            // Find token by refreshToken only
            const token = await KeyTokenModel.findOne({
                refreshToken,
                isRevoked: false,
                expiresAt: { $gt: new Date() }
            });

            if (!token) {
                throw new Error('Invalid refresh token');
            }

            // Add token to used tokens list
            token.refreshTokensUsed.push(refreshToken);
            await token.save();

            return token;
        } catch (error) {
            throw new Error(`Token validation failed: ${error.message}`);
        }
    }

	static async revokeToken(userId) {
		return await updateMany(
			{ user: userId, isRevoked: false },
			{ $set: { isRevoked: true } }
		);
	}

	static async updateKeyToken(id, publicKey, refreshToken) {
        try {
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 7); // 7 days from now
            const updatedToken = await KeyTokenModel.findByIdAndUpdate(
                id,
                {
                    publicKey,
                    refreshToken,
                    expiresAt
                },
                { new: true }
            );
            if (!updatedToken) throw new Error('Failed to update key token');
            return updatedToken;
        } catch (error) {
            throw new Error(`KeyToken update failed: ${error.message}`);
        }
    }
}

export default KeyTokenService

========================================
.\src\utils\index.js
========================================
import pick from 'lodash/pick.js';

const getInfoData = ({ fields=[], object={} }) => {
    return pick(object, fields);
}

export { getInfoData }